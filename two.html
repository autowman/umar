<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Logistics Flowchart Builder</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/interact.js/1.10.17/interact.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
      font-family: Arial, sans-serif;
    }
    body {
      background-color: #f4f4f4;
      color: #333;
    }
    .container {
      max-width: 100%;
      margin: auto;
      padding: 10px;
      text-align: center;
    }
    header {
      text-align: center;
      padding: 15px;
      background: #556B2F;
      color: white;
      border-radius: 10px;
      margin-bottom: 10px;
    }
    .canvas-container {
      width: 100%;
      height: 60vh;
      background: white;
      border: 2px dashed #ccc;
      position: relative;
      overflow: hidden;
    }
    .node {
      position: absolute;
      width: 180px;
      min-height: 80px;
      background-color: white;
      border: 2px solid #556B2F;
      border-radius: 8px;
      padding: 10px;
      cursor: move;
      text-align: center;
      z-index: 10;
    }
    .node input {
      font-size: 16px;
      width: 90%;
      text-align: center;
      border: 1px solid #ddd;
      padding: 5px;
      margin-top: 5px;
    }
    .connector {
      position: absolute;
      width: 15px;
      height: 15px;
      background-color: #556B2F;
      border-radius: 50%;
      cursor: pointer;
    }
    .connector-right {
      right: -7px;
      top: 50%;
      transform: translateY(-50%);
    }
    .connector-left {
      left: -7px;
      top: 50%;
      transform: translateY(-50%);
    }
    .delete-btn {
      position: absolute;
      top: 5px;
      left: 5px;
      background: #556B2F;
      color: white;
      border: none;
      cursor: pointer;
      padding: 2px 5px;
      font-size: 12px;
      border-radius: 50%;
    }
    .connection {
      position: absolute;
      height: 2px;
      background-color: #556B2F;
      z-index: 5;
      pointer-events: none;
    }
    .arrow {
      position: absolute;
      width: 0;
      height: 0;
      border-left: 8px solid transparent;
      border-right: 8px solid transparent;
      border-bottom: 12px solid #556B2F;
      transform-origin: center bottom;
      pointer-events: none;
    }
    .button {
      padding: 8px 12px;
      margin: 5px;
      border: none;
      border-radius: 5px;
      font-size: 14px;
      cursor: pointer;
      transition: 0.3s;
    }
    .add-btn { background: #4CAF50; color: white; }
    .export-btn { background: #D9534F; color: white; }
    .button:hover { opacity: 0.8; }
    .home-button {
      position: fixed;
      bottom: 20px;
      right: 20px;
      background: #556B2F;
      padding: 10px;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }
    .home-icon {
      width: 24px;
      height: 24px;
      stroke: white;
    }
  </style>
</head>
<body>
  <a href="index.html" class="home-button" title="Go to Homepage">
    <svg class="home-icon" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round">
      <path d="M3 9l9-7 9 7v11a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2z"></path>
      <polyline points="9 22 9 12 15 12 15 22"></polyline>
    </svg>
  </a>
  <div class="container">
    <header>
      <h1>Logistics Flowchart Builder</h1>
    </header>
    <button class="button add-btn" onclick="addNode()">Add Node</button>
    <div class="canvas-container" id="flowchart-canvas"></div>
    <br>
    <button class="button export-btn" onclick="exportAsPNG()">Export as PNG</button>
    <button class="button export-btn" onclick="exportAsPDF()">Export as PDF</button>
  </div>
  <script>
    var nodes = [];
    var connections = [];
    var connectingMode = false;
    var startConnector = null;

    function addNode() {
      const canvas = document.getElementById('flowchart-canvas');
      const node = document.createElement('div');
      node.classList.add('node');
      node.style.left = `${50 + nodes.length * 20}px`;
      node.style.top = `${50 + nodes.length * 20}px`;
      
      // Add delete button and input with larger font size
      node.innerHTML = `
        <button class='delete-btn' onclick='deleteNode(this)'>X</button>
        <input type='text' placeholder='Enter text'>
        <div class='connector connector-right' data-node-id='${nodes.length}' data-side='right'></div>
        <div class='connector connector-left' data-node-id='${nodes.length}' data-side='left'></div>
      `;
      
      canvas.appendChild(node);
      nodes.push(node);
      makeDraggable(node);
      setupConnectors(node);
    }

    function setupConnectors(node) {
      const rightConnector = node.querySelector('.connector-right');
      const leftConnector = node.querySelector('.connector-left');
      
      rightConnector.addEventListener('click', function() {
        if (connectingMode && startConnector) {
          // Complete the connection
          createConnection(startConnector, this);
          resetConnectingMode();
        } else {
          // Start a new connection
          startConnector = this;
          connectingMode = true;
        }
      });
      
      leftConnector.addEventListener('click', function() {
        if (connectingMode && startConnector) {
          // Complete the connection
          createConnection(startConnector, this);
          resetConnectingMode();
        } else {
          // Start a new connection
          startConnector = this;
          connectingMode = true;
        }
      });
    }

    function resetConnectingMode() {
      connectingMode = false;
      startConnector = null;
    }

    function createConnection(startConnector, endConnector) {
      // Don't connect to the same node
      if (startConnector.dataset.nodeId === endConnector.dataset.nodeId) {
        return;
      }
      
      const canvas = document.getElementById('flowchart-canvas');
      const connection = document.createElement('div');
      connection.classList.add('connection');
      
      const arrow = document.createElement('div');
      arrow.classList.add('arrow');
      
      canvas.appendChild(connection);
      canvas.appendChild(arrow);
      
      const connectionData = {
        startNodeId: parseInt(startConnector.dataset.nodeId),
        endNodeId: parseInt(endConnector.dataset.nodeId),
        startSide: startConnector.dataset.side,
        endSide: endConnector.dataset.side,
        connectionElement: connection,
        arrowElement: arrow
      };
      
      connections.push(connectionData);
      updateConnection(connectionData);
    }

    function updateConnection(connectionData) {
      const startNode = nodes[connectionData.startNodeId];
      const endNode = nodes[connectionData.endNodeId];
      
      if (!startNode || !endNode) {
        connectionData.connectionElement.remove();
        connectionData.arrowElement.remove();
        connections = connections.filter(conn => conn !== connectionData);
        return;
      }
      
      const startRect = startNode.getBoundingClientRect();
      const endRect = endNode.getBoundingClientRect();
      const canvasRect = document.getElementById('flowchart-canvas').getBoundingClientRect();
      
      // Calculate connector positions
      const startX = connectionData.startSide === 'right' ? 
        startRect.right - canvasRect.left :
        startRect.left - canvasRect.left;
      const startY = startRect.top + startRect.height/2 - canvasRect.top;
      
      const endX = connectionData.endSide === 'right' ? 
        endRect.right - canvasRect.left :
        endRect.left - canvasRect.left;
      const endY = endRect.top + endRect.height/2 - canvasRect.top;
      
      // Calculate length and angle of the connection
      const dx = endX - startX;
      const dy = endY - startY;
      const length = Math.sqrt(dx*dx + dy*dy);
      const angle = Math.atan2(dy, dx) * 180 / Math.PI;
      
      // Position the connection line
      connectionData.connectionElement.style.width = `${length}px`;
      connectionData.connectionElement.style.left = `${startX}px`;
      connectionData.connectionElement.style.top = `${startY}px`;
      connectionData.connectionElement.style.transform = `rotate(${angle}deg)`;
      connectionData.connectionElement.style.transformOrigin = '0 0';
      
      // Position the arrow
      connectionData.arrowElement.style.left = `${endX}px`;
      connectionData.arrowElement.style.top = `${endY}px`;
      connectionData.arrowElement.style.transform = `rotate(${angle - 90}deg)`;
      connectionData.arrowElement.style.transformOrigin = 'center';
    }

    function updateAllConnections() {
      connections.forEach(connectionData => {
        updateConnection(connectionData);
      });
    }

    function makeDraggable(element) {
      interact(element).draggable({
        inertia: true,
        modifiers: [
          interact.modifiers.restrictRect({ restriction: 'parent', endOnly: true })
        ],
        listeners: {
          move(event) {
            const x = (parseFloat(element.getAttribute('data-x')) || 0) + event.dx;
            const y = (parseFloat(element.getAttribute('data-y')) || 0) + event.dy;
            element.style.transform = `translate(${x}px, ${y}px)`;
            element.setAttribute('data-x', x);
            element.setAttribute('data-y', y);
            updateAllConnections();
          }
        }
      });
    }

    function deleteNode(button) {
      const nodeElement = button.parentElement;
      const nodeId = nodes.indexOf(nodeElement);
      
      // Remove connections associated with this node
      connections = connections.filter(conn => {
        if (conn.startNodeId === nodeId || conn.endNodeId === nodeId) {
          conn.connectionElement.remove();
          conn.arrowElement.remove();
          return false;
        }
        return true;
      });
      
      // Update node IDs for connections after removal
      connections.forEach(conn => {
        if (conn.startNodeId > nodeId) {
          conn.startNodeId--;
        }
        if (conn.endNodeId > nodeId) {
          conn.endNodeId--;
        }
      });
      
      // Remove the node and update nodes array
      nodeElement.remove();
      nodes = nodes.filter(node => node !== nodeElement);
      
      // Update connectors' data-node-id attributes
      nodes.forEach((node, index) => {
        const rightConnector = node.querySelector('.connector-right');
        const leftConnector = node.querySelector('.connector-left');
        if (rightConnector) rightConnector.dataset.nodeId = index;
        if (leftConnector) leftConnector.dataset.nodeId = index;
      });
    }

    function exportAsPNG() {
      // Clone the canvas and prepare it for export
      const original = document.getElementById('flowchart-canvas');
      const clone = original.cloneNode(true);
      document.body.appendChild(clone);
      
      // Remove connectors and fix positions for export
      const clonedNodes = clone.querySelectorAll('.node');
      clonedNodes.forEach((node, index) => {
        // Remove connectors
        node.querySelectorAll('.connector').forEach(conn => conn.remove());
        
        // Fix position for export
        const originalNode = nodes[index];
        const x = parseFloat(originalNode.getAttribute('data-x')) || 0;
        const y = parseFloat(originalNode.getAttribute('data-y')) || 0;
        
        node.style.transform = '';
        node.style.left = `${parseInt(node.style.left) + x}px`;
        node.style.top = `${parseInt(node.style.top) + y}px`;
      });
      
      // Export
      html2canvas(clone, {
        backgroundColor: 'white',
        scale: 2
      }).then(canvas => {
        const link = document.createElement('a');
        link.download = 'flowchart.png';
        link.href = canvas.toDataURL('image/png');
        link.click();
        clone.remove();
      });
    }

    function exportAsPDF() {
      // Clone the canvas and prepare it for export
      const original = document.getElementById('flowchart-canvas');
      const clone = original.cloneNode(true);
      document.body.appendChild(clone);
      
      // Remove connectors and fix positions for export
      const clonedNodes = clone.querySelectorAll('.node');
      clonedNodes.forEach((node, index) => {
        // Remove connectors
        node.querySelectorAll('.connector').forEach(conn => conn.remove());
        
        // Fix position for export
        const originalNode = nodes[index];
        const x = parseFloat(originalNode.getAttribute('data-x')) || 0;
        const y = parseFloat(originalNode.getAttribute('data-y')) || 0;
        
        node.style.transform = '';
        node.style.left = `${parseInt(node.style.left) + x}px`;
        node.style.top = `${parseInt(node.style.top) + y}px`;
      });
      
      // Export
      html2canvas(clone, {
        backgroundColor: 'white',
        scale: 2
      }).then(canvas => {
        const imgData = canvas.toDataURL('image/png');
        const pdf = new jspdf.jsPDF('landscape');
        const imgProps = pdf.getImageProperties(imgData);
        const pdfWidth = pdf.internal.pageSize.getWidth();
        const pdfHeight = (imgProps.height * pdfWidth) / imgProps.width;
        pdf.addImage(imgData, 'PNG', 10, 10, pdfWidth - 20, pdfHeight - 20);
        pdf.save('flowchart.pdf');
        clone.remove();
      });
    }

    // Add keyboard event to cancel connection mode
    document.addEventListener('keydown', function(event) {
      if (event.key === 'Escape' && connectingMode) {
        resetConnectingMode();
      }
    });

    // Add click event on canvas to cancel connection mode
    document.getElementById('flowchart-canvas').addEventListener('click', function(event) {
      if (connectingMode && event.target === this) {
        resetConnectingMode();
      }
    });
  </script>
</body>
</html>
